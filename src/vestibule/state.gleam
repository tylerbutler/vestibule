/// CSRF state generation and validation for OAuth2 flows.
///
/// State values are cryptographically random (256-bit / 32 bytes), providing
/// strong protection against CSRF attacks. However, this module only handles
/// generation and comparison — it does **not** enforce expiration or
/// single-use semantics.
///
/// ## Caller responsibilities
///
/// - **Store with a TTL.** State values should expire after a short window
///   (e.g., 10 minutes) to limit the replay window if a value is leaked
///   via browser history, logs, or referrer headers.
/// - **Delete after validation.** Once `validate` returns `Ok(Nil)`, the
///   stored state should be removed so it cannot be reused.
/// - **Pair with PKCE.** State prevents CSRF; PKCE prevents authorization
///   code interception. Both are generated by `vestibule.authorize_url`.
///
/// The `vestibule_wisp` state store implements these practices automatically
/// by deleting state on retrieval (one-time use) and setting a cookie TTL.
import gleam/bit_array
import gleam/crypto

import vestibule/error.{type AuthError, StateMismatch}

/// Generate a cryptographically random state parameter.
///
/// Returns 32 bytes (256 bits) of random data, base64url-encoded without
/// padding. The resulting string is safe for use in URL query parameters.
///
/// The returned value has no inherent expiration. Callers should store it
/// with a timestamp and enforce a TTL (e.g., 10 minutes).
pub fn generate() -> String {
  crypto.strong_random_bytes(32)
  |> bit_array.base64_url_encode(False)
}

/// Validate a received state parameter against the expected value.
///
/// Uses constant-time comparison to prevent timing attacks. Returns
/// `Ok(Nil)` on match, or `Error(StateMismatch)` on mismatch.
///
/// **Important:** This function only checks equality — it does not enforce
/// single-use or expiration. After a successful validation, callers should
/// delete the stored state to prevent replay attacks.
pub fn validate(received: String, expected: String) -> Result(Nil, AuthError(e)) {
  let received_bits = <<received:utf8>>
  let expected_bits = <<expected:utf8>>
  case crypto.secure_compare(received_bits, expected_bits) {
    True -> Ok(Nil)
    False -> Error(StateMismatch)
  }
}
