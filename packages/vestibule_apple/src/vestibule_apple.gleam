/// Apple Sign In strategy for vestibule.
///
/// Apple's OAuth implementation has several key differences from standard providers:
///
/// - **No userinfo endpoint**: User info is extracted from the `id_token` JWT
///   in the token response rather than from a separate API call.
/// - **`response_mode=form_post`**: Apple sends the callback as a POST with
///   form data. The vestibule core handles extracting callback params, so this
///   strategy just adds the parameter to the authorization URL.
/// - **Client secret is a JWT**: Apple requires the client_secret to be a signed
///   JWT. The caller is responsible for generating this JWT and providing it in
///   the Config. This strategy passes it through to the token endpoint.
/// - **User info only on first auth**: Apple only sends the full user object
///   (with name) on the first authorization. Subsequent authorizations only
///   include `sub` and `email` in the ID token.
/// - **JWT signature verification**: ID tokens are verified against Apple's
///   published JWKS keys using ES256.
///
/// ## Setup
///
/// Call `vestibule_apple.init()` once at application startup to initialize
/// caches, then use `vestibule_apple.strategy()` to create the strategy.
///
/// ```gleam
/// let apple = vestibule_apple.init()
/// let strategy = vestibule_apple.strategy(apple)
/// ```
import gleam/dict
import gleam/dynamic/decode
import gleam/json
import gleam/option.{type Option, None, Some}
import gleam/result
import gleam/string
import gleam/time/duration
import gleam/uri

import gleam/http/request
import gleam/httpc

import glow_auth
import glow_auth/authorize_uri
import glow_auth/token_request
import glow_auth/uri/uri_builder

import vestibule/config.{type Config}
import vestibule/credentials.{type Credentials, Credentials}
import vestibule/error.{type AuthError}
import vestibule/strategy.{type Strategy, Strategy}
import vestibule/user_info
import vestibule_apple/id_token_cache.{type IdTokenCache}
import vestibule_apple/jwks.{type JwksCache}
import vestibule_apple/jwt
import ywt/claim
import ywt/verify_key.{type VerifyKey}

/// Holds both the ID token cache and the JWKS cache.
/// Returned by `init()` and required by `strategy()`.
pub type AppleCache {
  AppleCache(id_tokens: IdTokenCache, jwks: JwksCache)
}

/// Initialize the Apple strategy's caches.
///
/// Must be called once at application startup before handling any
/// authentication flows. Returns the cache handle needed by `strategy()`.
///
/// ## Example
///
/// ```gleam
/// let apple = vestibule_apple.init()
/// let strategy = vestibule_apple.strategy(apple)
/// ```
pub fn init() -> AppleCache {
  AppleCache(id_tokens: id_token_cache.init(), jwks: jwks.init())
}

/// Create an Apple Sign In authentication strategy.
///
/// Requires the cache handle from `init()`. Apple requires
/// `response_mode=form_post` for the authorization URL, which is added
/// automatically. The client_secret must be a signed JWT generated by
/// the caller (see Apple's documentation).
///
/// ID tokens are verified against Apple's published JWKS keys with
/// claim validation for issuer, audience, and expiration.
pub fn strategy(apple: AppleCache) -> Strategy(e) {
  Strategy(
    provider: "apple",
    default_scopes: ["name", "email"],
    token_url: "https://appleid.apple.com/auth/token",
    authorize_url: do_authorize_url,
    exchange_code: fn(config, code, code_verifier) {
      do_exchange_code(apple, config, code, code_verifier)
    },
    fetch_user: fn(creds) { do_fetch_user(apple, creds) },
  )
}

/// Parse Apple token response JSON.
///
/// Apple's token response includes an `id_token` JWT containing user claims.
/// This function parses the response and returns both the Credentials and the
/// raw id_token string as a tuple.
pub fn parse_token_response(
  body: String,
) -> Result(#(Credentials, Option(String)), AuthError(e)) {
  // Try error response first
  let error_decoder = {
    use error_code <- decode.field("error", decode.string)
    use description <- decode.optional_field(
      "error_description",
      "",
      decode.string,
    )
    decode.success(#(error_code, description))
  }
  case json.parse(body, error_decoder) {
    Ok(#(code, description)) ->
      Error(error.ProviderError(code: code, description: description))
    _ -> parse_success_token(body)
  }
}

fn parse_success_token(
  body: String,
) -> Result(#(Credentials, Option(String)), AuthError(e)) {
  let decoder = {
    use access_token <- decode.field("access_token", decode.string)
    use token_type <- decode.field("token_type", decode.string)
    use expires_in <- decode.optional_field(
      "expires_in",
      None,
      decode.optional(decode.int),
    )
    use refresh_token <- decode.optional_field(
      "refresh_token",
      None,
      decode.optional(decode.string),
    )
    use id_token <- decode.optional_field(
      "id_token",
      None,
      decode.optional(decode.string),
    )
    decode.success(#(
      Credentials(
        token: access_token,
        refresh_token: refresh_token,
        token_type: token_type,
        expires_at: expires_in,
        scopes: [],
      ),
      id_token,
    ))
  }
  case json.parse(body, decoder) {
    Ok(parsed) -> Ok(parsed)
    _ ->
      Error(error.CodeExchangeFailed(
        reason: "Failed to parse Apple token response",
      ))
  }
}

/// Verify and decode an Apple ID token JWT.
///
/// Fetches Apple's JWKS public keys (cached), verifies the JWT signature
/// using ES256, and validates the `iss`, `aud`, and `exp` claims.
///
/// Returns the user's `sub` (uid) and `UserInfo` on success.
pub fn verify_id_token(
  jwt: String,
  keys: List(VerifyKey),
  client_id: String,
) -> Result(#(String, user_info.UserInfo), AuthError(e)) {
  let claims = [
    claim.issuer("https://appleid.apple.com", []),
    claim.audience(client_id, []),
    claim.expires_at(
      max_age: duration.minutes(10),
      leeway: duration.seconds(60),
    ),
  ]

  let payload_decoder = {
    use sub <- decode.field("sub", decode.string)
    use email <- decode.optional_field(
      "email",
      None,
      decode.optional(decode.string),
    )
    use email_verified <- decode.optional_field(
      "email_verified",
      None,
      decode.optional(flexible_email_verified_decoder()),
    )
    decode.success(#(sub, email, email_verified))
  }

  case
    jwt.decode(jwt: jwt, using: payload_decoder, claims: claims, keys: keys)
  {
    Ok(#(sub, email, email_verified)) -> {
      let verified_email = case email, email_verified {
        Some(addr), Some(True) -> Some(addr)
        _, _ -> None
      }
      Ok(#(
        sub,
        user_info.UserInfo(
          name: None,
          email: verified_email,
          nickname: email,
          image: None,
          description: None,
          urls: dict.new(),
        ),
      ))
    }
    Error(jwt.InvalidSignature) | Error(jwt.NoMatchingKey) ->
      Error(error.UserInfoFailed(
        reason: "Apple ID token signature verification failed",
      ))
    Error(jwt.TokenExpired(_)) ->
      Error(error.UserInfoFailed(reason: "Apple ID token has expired"))
    Error(jwt.InvalidIssuer(_, _)) ->
      Error(error.UserInfoFailed(reason: "Apple ID token issuer is invalid"))
    Error(jwt.InvalidAudience(_, _)) ->
      Error(error.UserInfoFailed(
        reason: "Apple ID token audience does not match client_id",
      ))
    Error(_) ->
      Error(error.UserInfoFailed(reason: "Failed to verify Apple ID token"))
  }
}

/// Decoder that handles email_verified as either a boolean or a string.
/// Apple sends email_verified as a string "true"/"false" in some cases
/// and as a boolean in others.
fn flexible_email_verified_decoder() -> decode.Decoder(Bool) {
  decode.one_of(decode.bool, [string_bool_decoder()])
}

fn string_bool_decoder() -> decode.Decoder(Bool) {
  decode.string
  |> decode.then(fn(s) {
    case s {
      "true" -> decode.success(True)
      _ -> decode.success(False)
    }
  })
}

fn do_authorize_url(
  config: Config,
  scopes: List(String),
  state: String,
) -> Result(String, AuthError(e)) {
  let assert Ok(site) = uri.parse("https://appleid.apple.com")
  let assert Ok(redirect) = uri.parse(config.redirect_uri)
  let client =
    glow_auth.Client(
      id: config.client_id,
      secret: config.client_secret,
      site: site,
    )
  let url =
    authorize_uri.build(
      client,
      uri_builder.RelativePath("/auth/authorize"),
      redirect,
    )
    |> authorize_uri.set_scope(string.join(scopes, " "))
    |> authorize_uri.set_state(state)
    |> authorize_uri.to_code_authorization_uri()
    |> uri.to_string()
  // Add response_mode=form_post (Apple requires this)
  let url = url <> "&response_mode=form_post"
  // Append any extra params from config
  let url =
    dict.fold(config.extra_params, url, fn(acc, key, value) {
      acc <> "&" <> uri.percent_encode(key) <> "=" <> uri.percent_encode(value)
    })
  Ok(url)
}

fn do_exchange_code(
  apple: AppleCache,
  config: Config,
  code: String,
  code_verifier: Option(String),
) -> Result(Credentials, AuthError(e)) {
  let assert Ok(site) = uri.parse("https://appleid.apple.com")
  let assert Ok(redirect) = uri.parse(config.redirect_uri)
  let client =
    glow_auth.Client(
      id: config.client_id,
      secret: config.client_secret,
      site: site,
    )
  let req =
    token_request.authorization_code(
      client,
      uri_builder.RelativePath("/auth/token"),
      code,
      redirect,
    )
    |> request.set_header("accept", "application/json")
  let req = append_code_verifier(req, code_verifier)
  case httpc.send(req) {
    Ok(response) -> {
      use body <- result.try(error.check_http_status(
        response.status,
        response.body,
      ))
      case parse_token_response(body) {
        Ok(#(creds, id_token)) -> {
          // Store the id_token + client_id in the cache so fetch_user can
          // verify and decode it
          case id_token {
            Some(token) ->
              id_token_cache.store(
                apple.id_tokens,
                creds.token,
                token <> "\n" <> config.client_id,
              )
            None -> Nil
          }
          Ok(creds)
        }
        Error(err) -> Error(err)
      }
    }
    Error(_) ->
      Error(error.NetworkError(
        reason: "Failed to connect to Apple token endpoint",
      ))
  }
}

fn do_fetch_user(
  apple: AppleCache,
  creds: Credentials,
) -> Result(#(String, user_info.UserInfo), AuthError(e)) {
  // Apple has no userinfo endpoint. User info comes from the id_token JWT
  // stored during exchange_code.
  use cached <- result.try(
    id_token_cache.retrieve(apple.id_tokens, creds.token)
    |> result.replace_error(error.UserInfoFailed(
      reason: "No Apple ID token found. Ensure exchange_code was called first and init() was called at startup.",
    )),
  )

  // The cache stores "id_token\nclient_id"
  case string.split_once(cached, "\n") {
    Ok(#(id_token, client_id)) -> {
      // Fetch JWKS keys and verify the token
      use keys <- result.try(jwks.get_keys(apple.jwks))
      verify_id_token(id_token, keys, client_id)
    }
    Error(_) ->
      // Fallback: cached value has no client_id separator (shouldn't happen)
      Error(error.UserInfoFailed(reason: "Cached Apple ID token is malformed"))
  }
}

/// Append code_verifier to the form-encoded request body when present.
fn append_code_verifier(
  req: request.Request(String),
  code_verifier: Option(String),
) -> request.Request(String) {
  case code_verifier {
    Some(verifier) -> {
      let body = case req.body {
        "" -> "code_verifier=" <> uri.percent_encode(verifier)
        existing ->
          existing <> "&code_verifier=" <> uri.percent_encode(verifier)
      }
      request.set_body(req, body)
    }
    None -> req
  }
}
